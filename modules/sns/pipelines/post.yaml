# post.yaml - í¬ìŠ¤íŒ… íŒŒì´í”„ë¼ì¸
# ì½˜í…ì¸  íì—ì„œ ê°€ì ¸ì™€ì„œ í¬ìŠ¤íŒ…í•˜ëŠ” íŒŒì´í”„ë¼ì¸

pipeline:
  id: post-content
  name: "ì½˜í…ì¸  í¬ìŠ¤íŒ…"
  description: "íì—ì„œ ì½˜í…ì¸ ë¥¼ ê°€ì ¸ì™€ ê²€ì¦ í›„ í¬ìŠ¤íŒ…"

  # === ìŠ¤ì¼€ì¤„ ===
  schedule:
    cron: "0 10,14,19 * * *"           # í•˜ë£¨ 3íšŒ: 10ì‹œ, 14ì‹œ, 19ì‹œ
    timezone: "Asia/Seoul"
    enabled: true

  # === ì‹¤í–‰ ì¡°ê±´ ===
  conditions:
    # ê·œì¹™ ê¸°ë°˜ íƒ€ì´ë° ì²´í¬
    timing_check:
      use_rules: true
      rules_path: "state/rules.yaml"
      check: "timing.best_hours"
      confidence_threshold: 0.5

  # === ì‹¤í–‰ ë‹¨ê³„ ===
  steps:
    # --- Step 1: ê·œì¹™ ë¡œë“œ ---
    - name: "load_rules"
      action: "read_yaml"
      path: "state/rules.yaml"
      output: "rules"

    # --- Step 2: íƒ€ì´ë° ì²´í¬ ---
    - name: "check_timing"
      action: "evaluate"
      condition: |
        rules.timing.confidence < 0.5 OR
        current_hour in rules.timing.best_hours OR
        rules.timing.best_hours.length == 0
      on_fail:
        action: "skip_with_log"
        message: "í˜„ì¬ ì‹œê°„({current_hour}ì‹œ)ì€ ìµœì  í¬ìŠ¤íŒ… ì‹œê°„ì´ ì•„ë‹™ë‹ˆë‹¤"

    # --- Step 3: íì—ì„œ ì½˜í…ì¸  ê°€ì ¸ì˜¤ê¸° ---
    - name: "get_content"
      action: "queue_pop"
      query: |
        SELECT * FROM content_queue
        WHERE status = 'pending'
        AND (scheduled_at IS NULL OR scheduled_at <= datetime('now'))
        ORDER BY priority DESC, created_at ASC
        LIMIT 1
      output: "content"
      on_empty:
        action: "exit"
        message: "í¬ìŠ¤íŒ…í•  ì½˜í…ì¸ ê°€ ì—†ìŠµë‹ˆë‹¤"

    # --- Step 4: í†¤ ì ìš© ---
    - name: "adapt_tone"
      service: "shared/tone/${content.target_channel.tone_ref}"
      input: "${content.raw_content}"
      output: "toned_content"

    # --- Step 5: ê¸¸ì´ ì¡°ì • ---
    - name: "adapt_length"
      service: "shared/transformer/adapt-length"
      input: "${toned_content}"
      params:
        target_length: "${content.target_channel.max_length}"
        platform: "${content.target_channel.id}"
      output: "final_content"

    # --- Step 6: ìœ ì‚¬ë„ ê²€ì¦ ---
    - name: "validate_similarity"
      service: "shared/validator/similarity"
      input: "${final_content}"
      params:
        platform: "${content.target_channel.id}"
      on_fail:
        action: "rephrase"
        service: "llm_rephrase"
        max_retries: 2

    # --- Step 7: ê¸ˆì§€ì–´ ê²€ì¦ ---
    - name: "validate_forbidden"
      service: "shared/validator/forbidden"
      input: "${final_content}"
      on_fail:
        action: "skip"
        message: "ê¸ˆì§€ëœ ì½˜í…ì¸  ê°ì§€: {matched_pattern}"

    # --- Step 8: ê²€í†  (ì„ íƒì ) ---
    - name: "review"
      enabled: "${config.require_review}"
      service: "shared/approval/telegram"
      input: "${final_content}"
      params:
        target_channel: "${content.target_channel.name}"
        scheduled_time: "now"
      timeout_minutes: 60
      on_timeout: "skip"
      on_reject:
        action: "mark_rejected"
        update_queue: true

    # --- Step 9: í¬ìŠ¤íŒ… ì‹¤í–‰ ---
    - name: "execute_post"
      action: "channel_post"
      channel: "${content.target_channel.id}"
      script: "${content.target_channel.actions.post.script}"
      input: "${final_content}"
      output: "post_result"

    # --- Step 10: ê²°ê³¼ ê¸°ë¡ ---
    - name: "record_result"
      action: "db_insert"
      table: "posts"
      data:
        platform: "${content.target_channel.id}"
        content: "${final_content}"
        posted_at: "now()"
        post_id: "${post_result.post_id}"
        status: "posted"
        queue_id: "${content.id}"

    # --- Step 11: í ì—…ë°ì´íŠ¸ ---
    - name: "update_queue"
      action: "db_update"
      table: "content_queue"
      where: "id = ${content.id}"
      set:
        status: "posted"
        posted_at: "now()"
        post_id: "${post_result.post_id}"

    # --- Step 12: í¬ë¡œìŠ¤ í¬ìŠ¤íŒ… (ì„ íƒì ) ---
    - name: "cross_post"
      enabled: "${content.target_channel.cross_posting.enabled}"
      for_each: "target in content.target_channel.cross_posting.target_channels"
      delay_minutes: "${content.target_channel.cross_posting.delay_minutes}"
      steps:
        - action: "queue_add"
          table: "content_queue"
          data:
            raw_content: "${final_content}"
            target_channel: "${target}"
            source_post_id: "${post_result.post_id}"
            scheduled_at: "now() + ${delay_minutes} minutes"
            priority: -1               # ë‚®ì€ ìš°ì„ ìˆœìœ„

  # === ê²°ê³¼ ì²˜ë¦¬ ===
  on_complete:
    - action: "notify"
      channel: "telegram"
      message: |
        âœ… í¬ìŠ¤íŒ… ì™„ë£Œ

        **ì±„ë„**: ${content.target_channel.name}
        **ì½˜í…ì¸ **: ${final_content.substring(0, 100)}...

        ğŸ“Š ëŒ€ê¸° ì¤‘ì¸ ì½˜í…ì¸ : ${queue_remaining}ê°œ

    - action: "log"
      message: "Posted to ${content.target_channel.id}: ${post_result.post_id}"

    # 24ì‹œê°„ í›„ ë¶„ì„ íŠ¸ë¦¬ê±°
    - action: "schedule_task"
      task: "analyze_post_performance"
      delay_hours: 24
      params:
        post_id: "${post_result.post_id}"

  on_error:
    - action: "notify"
      channel: "telegram"
      message: "âŒ í¬ìŠ¤íŒ… ì‹¤íŒ¨: ${error}"

    - action: "db_update"
      table: "content_queue"
      where: "id = ${content.id}"
      set:
        status: "failed"
        error: "${error}"
        retry_count: "retry_count + 1"

    # ì¬ì‹œë„ (ìµœëŒ€ 3íšŒ)
    - action: "retry"
      max_attempts: 3
      delay_minutes: 30
      condition: "retry_count < 3"

  # === ë¡œê¹… ===
  logging:
    log_runs: true
    log_path: "data/pipeline_post.json"
    include_content: true
